*** GL 요약 ***
1. GL 파이프라인
2. GL 좌표 변환 파이프라인
3. GL 버퍼

[ GL 파이프라인 ]
- 구성 요소
	- 3차원 기하 물체 처리(Geometry Processing)
	- 2차원 영상 처리 과정(Image Processing)
	
< 디스플레이 리스트 >
- 정점 데이터나 화소 데이터는 컴파일된 형태로 디스플레이 리스트에 저장
- 디스플레이 리스트가 실행되면 해당 데이터들은 파이프라인으로 보내짐
- 데이터의 종류에 따라 다른 파이프라인로 보내짐
	- 정점 데이터는 이벨류에이터 -> 정점 연산 파이프라인으로 감
	- 화소 데이터는 화소 연산 파이프라인으로 감
	- 두 데이터들은 래스터 변환/스캔 변환 프로세서에서 만나게 된다

< 정점 데이터 관련 파이프라인 >		
- 이밸류에이터(evaluator)
	- 스플라인 곡선 사용시 실행
		- 스플라인 곡선 미사용시 바로 정점 연산 파이프라인으로 감
	- 주어진 제어점으로부터 곡선/곡면의 정점좌표/법선 벡터 등을 계산하는 프로세서
- 정점 연산(per-vertex operations)
	- 정점 데이터에 모델/시점/투상 변환 등의 기하 변환을 가하는 작업
	- 조명 사용시, 시점 좌표계에서 정점의 색이 계산
	- 투상 변환까지 정점 연산 프로세스에서 이루어짐
- 기본 요소 조합(primitive assembly)
	- 정점 연산에서 변환된 정점 위치로부터 기본 요소인 선분/다각형을 구성하는 작업
	- 절단 작업이 진행됨 i.e 투상 변환
		- 점 : 점을 제외시키거나 포함시키는 작업
		- 선분/다각형 : 절단 결과 새로운 정점이 생성
	- 원근 분할, 뷰포트 변환이 가해져 완전한 기하 기본 요소 생성
	- 최종적으로 절단된 정점의 위치/색/깊이/텍스처 좌표 등의 정보로 구성
	- 이후 텍스처 관련 정보들은 텍스처 좌표 생성 파이프라인에 의해 텍스처 정보가 업데이트
- 텍스처 좌표 생성
	- 주어진 정점 좌표로부터 텍스처 좌표를 계산하는 작업
	- 별도의 파이프라인을 따라 진행하고, 래스터 변환시 텍스처 매핑이 일어나기 전에 완료되어야 함
	
< 화소 데이터 관련 파이프라인>
- 화소 연산(Pixel Operation)
	- 메인 메모리에 압축되어 저장된 화소 데이터를 복원
	- 크기 조절/화소맵처리/클리핑 등의 화소 변환 작업을 거침
	- 변환된 데이터는 텍스처 메모리나 래스터 변환 프로세서로 보내짐
	

< 래스터 변환 >
- 기하 기본 요소와 화소 기본요소를 프래그먼트로 변환하는 프로세스
- 프래그먼트
	- 프레임 버퍼에 기록되기 이전 단계의 화소
		- 화면 화소의 색은 프레임 버퍼에 값이 기록되는 순간 결정
	- 화소에 대응하는 추상적인 개념
	- 화소 위치, 색, 깊이, 텍스처 등 하나의 화소를 채우기 위해 필요한 정보를 지닌 기본 단위
	- 래스터 변환에 의한 결과
- 래스터 변환 이후 파이프라인의 모든 작업은 프래그먼트 단위로 병렬 처리
	

< 텍스처 매핑 프로세스 >


< 컬러 섬 프로세스 >
- 지엘의 래스터 변환 단계에서 별도로 보간된 정점의 경면광을 텍스처 매핑 결과인 텍스처 색 위에 덧씌우는 작업
  (why?) 다각형에 경면광을 포함하면, 텍스처 처리 결과가 단순히 텍스처 색의 밝기만 밝아지게 한다
		 경면광 및 텍스처 처리 결과가 부정확해진다
		 => 텍스처 매핑 처리 이후 경면광 처리를 해야 한다

< 안개 효과 프로세스 >
- 안개 효과 : 안개, 아지랑이, 연기, 공해, 대기 등 공기 상태로 인한 현상
	- 물체를 흐리게 만드는 현상
- 안개 효과는 물체의 거리에 따라 달라진다
	- 거리에 따라 물체를 흐리게 만드는 것
	- 멀리 있는 물체일 수록 더욱 뿌옇게 보인다
- 물체색과 배경색의 혼합 비율을 조절하여 효과를 낸다
- 안개 모드 : 안개 함수를 설정
	- 안개 함수 : 거리에 따른 물체 색의 강도를 줄이는 함수
	- 거리 값 z는 프레임 버퍼 화소에 대응되는 깊이 버퍼 값을 사용
	- 물체색과 안개색을 안개 함수에 의해 선형으로 혼합한 것이 최종색
		- 안개함수값*물체색 + (1-안개함수값)*안개색


< 프래그먼트 연산 >
- 시저 테스트
- 알파 테스트
- 스텐실 테스트
- 깊이 버퍼 테스트
- 블렌딩
- 디더링
- 논리 연산


[ GL 좌표 변환 파이프라인 ]
1. 모델 좌표 (Model Coordinate System)
- 각 물체별로 설계상 편의를 위해 해당 물체 하나를 표현하기 위한 좌표계
  i.e 특정 모델을 위한 좌표
- 모델 좌표계의 원점과 축의 방향은 해당 물체를 모델링할 때 편의에 의해 결정

	< 모델 변환 >
	- 물체에 기하 변환(이동, 회전, 크기조절)을 가하여 물체의 모습을 변환하는 작업
	- 전역 좌표계를 모델 좌표계로 일치시키는 작업
	- glScalef, glRoatef, glTanslatef

2. 전역 좌표 (World Coordinate System) 
- 모델 좌표에 모델 행렬 변환을 적용한 좌표
- 장면 내의 모든 물체를 한꺼번에 표현하는 좌표계
- 각 모델 좌표계는 기설정된 전역 좌표계를 기준으로 변환되어 물체간 상대적 위치가 표현된다

	< 시점 변환 >
	- 전역 좌표계에 존재하는 물체를 관찰하기 위해 카메라의 위치와 방향을 설정하는 작업
	- 전역 좌표계 기준의 좌표를 관찰자 시점을 기준으로 설정된 시점 좌표계 기준의 좌표로 변환하는 작업
	  <=> 시점 좌표계를 전역 좌표계와 일치시키기 위한 좌표계 변환
	- gluLookAt(a,b,c)
		a) 카메라의 위치(전역 좌표 기준)
		b) 초점 위치 i.e 카메라가 바라보는 점
		c) 카메라의 상향벡터(기울기)
	
3. 시점 좌표 (View Coordinate System)
- 전역 좌표에 뷰 행렬 변환을 적용한 좌표
- glMatrixMode(GL_MODELVIEW)에서 설정한 모델/뷰 행렬 변환 이후 얻는 좌표
- 시점 변환에서 설정한 카메라의 위치를 반영한 좌표계
- 화면에 보이는 물체는 시점의 위치와 방향에 좌우
  => 주어진 시점에서의 물체를 표현하기 위한 좌표계

	< 조명 >
	- 물체 정점에 색을 부여하는 작업
	- 광원과 물체 특성을 감안하여 정점에서의 빛 세기를 계산하는 작업
	- 조명에 대한 계산은 시점 좌표계에서 가해진다
	- 물체 정점에 모델 뷰 행렬을 구한 직후 and 투상 변환이 일어나기 직전에 가해진다
	- 지엘은 지역 조명 모델(주변광+확산광+경면광)을 적용

	< 투상 변환 - 정규화 변환 >
	- 투상 방법(평행, 원근) 및 가시 부피를 설정
	- 설정된 가시 부피를 [-1,1]*[-1,1]*[-1,1] 크기의 정규화 가시부피로 변환하는 작업
	  => 정규화 가시 부피를 사용함으로써 이후 투상 변환 관련 파이프라인 처리 구조가 동일해진다
	- 카메라의 렌즈 및 촬영 기법을 반영하는 기하 변환
	- 시점 좌표계를 절단 좌표계로 변환하는 작업
	- glOrtho, glFrustum, gluPerspective
	
	< 후면 제거 >
	- 물체의 후면을 판단하여 제거하는 작업
	  : 시점에서 눈에 보이지 않는 면을 후면으로 정의
	- 각 면의 법선 벡터와 시점으로 향하는 벡터의 내적을 통해 해당 면의 전면/후면 판단
	- 투상 행렬을 통한 정규화 변환 이후에는 법선 벡터의 z값만을 기준으로 후면 여부 판단
	  => 계산 속도 향상
	- 후면으로 판정된 면을 그래픽 파이프라인에서 미리 제외함으로써 이후 그래픽 처리 시간 단축
	- glEnable(GL_CULL_FACE)를 통해 후면 제거 모드 활성화

4. 절단 좌표 (Clip Coordinate System)
- 정규화 변환에 의해 얻어지는 동차 좌표계
  => 가시 부피는 [-1,1]*[-1,1]*[-1,1] 크기의 정육면체로 정규화
- 가시 부피에 대한 절단 알고리즘(Ch8)이 적용되어 물체를 절단한다
	- 가시부피가 정규화되어 있기 때문에 절단 알고리즘 실행 속도가 빠르다
	- GL에서는 서더런드-핫지먼 알고리즘 사용
	
** 절단 알고리즘이 정규화 장치 좌표에서 적용되지 않는 이유 **
	- 절단 좌표계 : 정규화 가시 부피를 동차좌표 (x,y,z,w)로 바라본다
	- 정규화 장치 좌표계 : 정규화 가시 부피를 (x/w, y/w, z/w)로 바라본다
	- 정규화 장치 좌표는 절단 선분이 시점의 앞(Q)과 뒤(P)에 걸쳐 있는 경우에 문제가 발생
		- Q의 점이 정규화 장치 좌표에서는 시점의 뒤로 넘어감으로써 왜곡
	
** 절단 알고리즘을 절단 좌표에서 사용하는 이유
	- 절단 좌표계는 동차 좌표를 사용
	- 동차 좌표에서는 각 축과 w에 대한 평면 (x,w), (y,w), (z,w)에 대해서만 계산
	- w 값과의 비교만으로 정점의 내외부 판정 가능
	
	< 절단 >
	- 절단 좌표계에서 가해지는 작업으로 시점과 관련된 파라미터와 무관하게 절단을 가할 수 있다
	- 정규화 가시부피를 기준으로 절단이 가해지므로, 절단면들이 고정되어 있다
	  => 절단 작업의 하드웨어화가 가능하여 실행 속도 향상
	- 지엘은 4차원 동차 좌표계에서 w값을 이용한 서더런드-핫지먼 알고리즘 사용
	
	< 원근 분할 >
	- 현재까지의 행렬 계산은 동차좌표에서 이루어짐
	- 동차좌표에서 실제 3차원 좌표계의 좌표로 변환하는 과정
	  i.e (x,y,z,a) -> (x/a, y/a, z/a)
	- 절단 좌표계를 정규화 장치 좌표계로 변환하는 작업
	- 평행 투상의 경우 원근 분할이 불필요하여 절단 좌표계와 정규화 장치 좌표계가 동일한 의미를 지닌다

5. 정규화 장치 좌표
- 정규화 변환과 절단에 의해 모든 물체의 좌표는 [-1, 1]*[-1,1]*[-1,1] 내부에 있다
- 실제 3차원 공간을 표한하기 위한 3차원 좌표계

	< 뷰 포트 변환 >
	- 3차원 정규화 장치 좌표에서 2차원 화면 좌표로 투상을 해주는 좌표
	- 뷰포트 : 투상면 위에 있는 유한 크기의 사각형으로 이 내부에만 영상이 맺힘 i.e 카메라 필름 역할
	- 뷰포트의 크기와 위치를 설정함으로써 필름에 맺히는 영상의 크기를 늘리거나 줄이는 작업
	- 뷰 표트 변환은 3차원 정규화 장치 좌표계에서 3차원 뷰포트 좌표계로 가는 작업
	  => 깊이 정보(z값)을 유지하여 이후 깊이 정보를 처리해야 하는 작업(은면 제거)에 활용
	  i.e x,y 좌표에 대한 크기 조절 및 이동 변환
	- 가시 부피 전면 절단면의 종횡비와 뷰포트의 종횡비가 일치하지 않으면 영상에 왜곡 발생
	- glViewport


6. 뷰 포트 좌표
- 뷰 포트 변환 결과로 나오는 뷰 포트 좌표계는 [w0,w0+w]*[h0,h0+h]*[-1,1]로 제한된 3차원 부동 소수 정밀도의 좌표계
- 레스터 변환, 은면 제거, 음영은 거의 같은 시기에 처리되는 작업
- 텍스처 매핑은 화소 관련 별도 파이프라인을 통해 처리

	< 래스터 변환 >
	- 화소로의 사상
	  i.e 부동 소수 정밀도로 표현된 정점의 뷰 포트 좌표를 정수 정밀도의 화면 좌표로 변환하는 작업
	- 정점의 뷰포트 좌표를 화면 좌표로 바꾸는 것은 래스터 변환의 가장 기초적인 작업
	- 뷰 포트 변환 결과 정점을 대상으로 래스터 변환 적용
	- 물체 공간의 점,선,면을 모두 화소 공간으로 사상
	  : 물체의 정점을 화소로 사상한 후, 사상된 화면 좌표계 상의 정점 좌표를 이용하여 물체의 선,면에 대한 래스터 변환 진행
	- 은면 제거와 나란히 진행
	  (why?) 래스터 변환이 끝나면, 어느 화소가 어느 정점에서 왔는지 알 수 가 없어 해당 화소의 깊이나 색을 보간할 수 없음
	
	< 은면 제거 >
	- 다른 물체면에 가려져서 보이지 않는 면을 제거하는 작업
	- 보이지 않는 면을 제거하기 위한 마지막 작업
	  : 후면 제거 -> 절단 -> 은면 제거
	- 은면 제거는 물체간 깊이(z값) 관계에 의해 결정
	  => 은면 제거는 물체 정점의 깊이 정보가 필요하므로 2차원 투상이 완료되기전에 진행되어야 한다
	- 지엘은 Z-버퍼(깊이 버퍼)를 이용한 지버퍼 알고리즘 사용
	
	< 음영 >
	- 조명 모델에 의해 계산된 정점의 색상으로부터 해당 물체면의 내부 색을 부여하는 작업
	- 래스터 변환에 의해 다각형 내부가 어떤 화소로 사상될지 결정될 때 해당 화소의 음영(색)을 결정
	- 다각형 정점 및 내부점에 대한 법선 벡터 보간/색 보간 방식에 따라 셰이딩 방식이 구분된다
	
	
	< 텍스처 맵핑 >
	- 래스터 변환으로 결정된 화면 화소마다 텍스처에 의한 색이 반영
	  i.e 화면 좌표에 대응하는 정규화된 텍스처 좌표를 찾는 작업
	- 입력된 텍스처는 "화소 연산"이라는 별도의 파이프라인을 거쳐 진행
	- 화소 연산 결과와 기하 파이프라인(모델뷰/정규화/뷰포트 등)의 결과가 합쳐서 래스터 변환 파이프라인에서 만난다
	  i.e 텍스처 맵핑은 물체 정점에 대한 모든 기하 파이프라인 처리가 끝난 시점에서 가해진다
	  
	< 프래그먼트 연산 >
	- 래스터 변환을 가한 모든 요소(점,선, 삼각형 등의 기하 물체 및 화소 파이프라인에 입력된 비트맵 영상과 화소)의 결과 정보는 프래그먼트 단위로 표시
	  => 래스터 변환 이후 파이프라인의 모든 작업은 프래그먼트 단위로 병렬 처리
	- 프래그먼트가 화소로 변하여 프레임 버퍼에 저장되기 전까지의 일련의 연산
	- 모든 프래그먼트 테스트를 통과한 프레그먼트에 일련의 연산이 가해지고 최종 결과가 프레임 버퍼에 저장됨으로써 화면에 출력
	
	
7. 화면 좌표
- 실제 디스플레이의 화소 단위로 좌표를 표시한 좌표계
- 일반적으로 화면의 좌상단을 원점으로 하여 x축은 오른쪽, y축은 아래쪽 방향으로 진행
- 정수 정밀도의 좌표계로 하나의 좌표는 일정한 크기를 지니는 하나의 화소를 대표한다
- 화면 좌표에 주소를 할당하는 방법 1
	- 화소의 정중앙 좌표가 해당 화소 대표
	- ex)  [0,1]*[0,1] 화소에 해당하는 0번째 주소는 (1/2, 1/2)
- 화면 좌표에 주소를 할당하는 방법 2
	- 좌표축 및 좌표가 화소 경계선과 교차하는 곳으로 설정
	- ex)  [0,1]*[0,1] 화소에 해당하는 0번째 주소는 (0,0)
	- GL을 포함한 모든 소프트웨어에서 사용하는 방식





[ GL 버퍼 ]
1. 프런트 버퍼, 백 버퍼
- 프런트 버퍼 
	- 현재 화면에 보이는 영상이 기록된 버퍼
	- mode : GL_FRONT
	- glutInitDisplayMode(GLUT_SINGLE)을 호출하여 프런트 버퍼만 활성화
	- glClearColor(특정값)를 통해 버퍼를 특정값으로 초기화
- 백 버퍼
	- mode : GL_BACK
	- glutInitDisplayMode(GLUT_DOUBLE)을 호출하여 프런트 버퍼와 백 버퍼 활성화
	- 더블 버퍼링 사용시 다음 화면에 보일 영상이 기록된 버퍼
	- glutSwapBuffers를 이용하여 프론트/백 버퍼의 역할 교대
	
2. 좌측 버퍼, 우측 버퍼
- 입체 영상을 위한 스테레오 버퍼
- glGetBooleanv(GL_STEREO)를 이용하여 그래픽 카드의 스테레오 버퍼 지원 여부 확인 가능

3. 보조 버퍼
- 사용자 임의로 사용 가능
- 화면 디스플레이에 직접 사용 불가능
- 보조 버퍼의 내용을 화면에 디스플레이 하기 위해서는 해당 내용을 프런트 버퍼로 옮겨야함
- glGetIntegerv(GL_AUX_BUFFERS)를 이용하여 그래픽 카드에 몇 개의 보조 버퍼가 지원되는지 확인 가능

4. 깊이 버퍼
- 지-버퍼 알고리즘에서 사용하는 버퍼
- glutInitDisplayMode(GLUT_DEPTH)를 호출하여 활성화
- glClearDepth(특정값)를 통해 버퍼를 특정값으로 초기화

4. A 버퍼
- 일반적인 A 버퍼 정의
	- 프레임 버퍼, 깊이 버퍼, 알파 채널, 안티 에일리어싱 등의 기능을 통합한 하드웨어
	- 물체들이 연결 리스트 형태로 저장
		- 모든 물체들은 RGB 세기, 투명도, 깊아, 화소 점유율 등의 정보를 저장
		- 화소 점유율 : 화소의 색을 결정하려면 투명도와 함께 화소 점유율도 감안해야 한다
- GL에서의 A 버퍼 정의
	- 단일 버퍼로, 복수 개의 영상을 누적하여 저장하는 버퍼
	- glAccum(연산 파라미터, value)
	- 대부분 지엘 환경에서는 A 버퍼를 소프트웨어적으로 구현하므로 렌더링 속도가 저하될 가능성 존재
- GL에서의 사용 예시 1 : 화면 안티 에일리어싱
	- 하나의 영상을 조금씩 변형시켜 얻은 영상들을 평균내어 에일리어싱을 해결하는 방법
	- glAccum(CL_ACCUM, 1.0/n)을 이용하여 A 버퍼에 컬러 데이터 누적
- GL에서의 사용 예시 2 : 필드 깊이 조절
	- 일반 카메라처럼 초점 거리로부터 물체가 멀어질수록 흐릿하게 보이는 효과를 주고 싶은 상황
	- 초점 평면을 설정하고 필드 깊이에 따라 변화를 주어야함
	- 가시 부피와 초점 평면의 교차면이 동일하도록 시점을 변화시키면서 영상을 변형
		- 변형된 영상들을 이용하여 A 버퍼에 누적
		- 가까운 물체일수록 상대적으로 또렷하게 보임
- GL에서의 사용 예시 3 : 모션 블러
	- 동작 경로를 따라가면서 동일한 물체를 중복하여 그리는 것
	- 물체를 이동하면서 glAccum(GL_MULT, decayFactor) 함수를 호출
- GL에서의 사용 예시 4 : 소프트 섀도
	- 여러 광원에 의한 소프트 섀도 효과
	- 각 단계에서 하나의 광원만 활성화하여, 이들을 A 버퍼에 각각 누적하여 그려낸다
- glutInitDisplayMode(GLUT_ACCUM)를 호출하여 활성화
- glClearAccum(특정값)를 통해 버퍼를 특정값으로 초기화

5. 스텐실 버퍼
- 스텐실 테스트에서 사용하는 테스트 기준용 버퍼
- 화면 출력을 제한하고 싶은 영역을 저장하는 버퍼
- 임의 모양을 스텐실 버퍼에 직접 저장은 불가능
	- 해당 모양을 프레임 버퍼에 저장시킨뒤, z-pass 함수로 스텐실 버퍼에 저장
- glutInitDisplayMode(GLUT_STENCIL)를 호출하여 활성화
- glClearStencil(특정값)를 통해 버퍼를 특정값으로 초기화







