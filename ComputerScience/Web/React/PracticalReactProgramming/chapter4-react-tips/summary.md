# Chapter 4. 리액트 실전 활용법

## Section 1. 가독성과 생산성을 고려한 컴포넌트 코드 작성법
* 컴포넌트 코드 작성을 위한 2가지 규칙
	* 작성하는 사람 입장 : 유지 보수가 쉬운 코드
	* 사용하는 사람 입장 : 컴포넌트의 인터페이스를 쉽게 파악할 수 있는 코드

### 추천하는 컴포넌트 파일 작성법
* 전체적인 순서
	* 최상단은 컴포넌트의 속성값 정의
	* 컴포넌트 함수 정의
	* 컴포넌트 바깥의 변수 및 함수 정의
* 속성값 정의
	* prop-types를 이용
	* 컴포넌트 함수의 매개 변수 타입을 정의하는 부분
	* 사용자 입장에서 사용하기 쉽게 최상단에 작성
* 컴포넌트 함수
	* 매개변수는 명명된 매개변수로 정의
		* 이후 구현부에서 props를 반복적으로 사용할 필요가 없어짐
	* 컴포넌트의 이름은 반드시 작성
		* export default를 사용하더라도 이름 작성
		* 이름이 없는 컴포넌트는 리액트 개발자 도구로 디버깅이 어려움
* 외부 변수 및 함수
	* 변수는 상수 및 대문자로 작성
	* 객체 생성이 컴포넌트 자체와 관련없는 경우 외부에서 정의하는 것이 좋음
		* 컴포넌트가 렌더링될 때마다 해당 객체를 생성하여 성능이 떨어질 수 있음
* 컴포넌트 내부에서의 코드 순서
	* 기능별로 코드를 분리
		* 상태값은 상단에 작성
		* 상태값을 변경하는 useEffect 등은 useState 바로 밑에 작성
	* 기능이 많아지면 커스텀 훅으로 분리
		* 커스텀 훅으로 분리하면, 같은 기능을 다른 부분에서 재사용 가능
		* 재사용을 안하더라도 컴포넌트 코드가 복잡해지면 커스텀 훅으로 분리
		
### 속성값 타입 정의하기 : prop-types
* prop-types는 속성값의 타입 정보를 정의할 때 사용하는 리액트 공식 패키지
	* 속성값의 타입 정보는 컴포넌트 코드의 가독성을 위해 필수로 작성
	* 동적 타입 언어(typescript)를 사용하지 못하는 상황에서 유용
	* 속성값 타입 검사는 개발 모드에서만 동작
	* 속성값 타입을 정의함으로써 훌륭한 문서가 됨
* 정의 방법
	```
		MyComponent.propTypes = {
			name: PropTypes.bool.isRequired,
			age: PropTypes.number.isRequired,
			description: PropTypes.string,
			onChangeName: PropTypes.func
		}
	```
	* PropTypes.* 형태로 타입 정의
	* PropTypes.*.isRequired는 필수값
	* PropTypes.func는 함수 타입
		* 함수의 매개변수 및 반환값의 타입은 정의 불가능
		* 문서화를 위해 해당 정보를 주석으로 추가
* prop-types로 정의할 수 있는 타입
	* PropTypes.element	: 리액트 요소
	* PropTypes.node : 컴포넌트 함수가 반환할 수 있는 모든 것
	* PropTypes.instanceOf(클래스) : 클래스로 생성된 객체
	* PropTypes.oneOf(배열)	: 배열 요소 중 하나의 값(enum)
	* PropTypes.oneOfType(배열) : 배열 요소 타입 중 하나를 만족
	* PropTypes.arrayOf(PropTypes.*) : 특정 타입으로 구성된 배열
	* PropTypes.shape({}) : 특정 객체의 속성값 타입들을 정의
	* PropTypes.objectOf(PropTypes.*) : 객체의 속성값들이 특정 타입만 가짐

### 가독성을 높이는 조건부 렌더링
* 조건부 렌더링
	* 컴포넌트 함수 내부에서 특정 조건에 따라 선택적으로 렌더링하는 것
	* 컴포넌트 함수의 return이 조건에 따라 달라지는 것
	* 삼항 연산자보다는 && 연산자가 가독성이 좋음
* JSX 내에서 조건부 렌더링을 무분별하게 사용하면 가독성이 떨어짐
	* 조건부 렌더링 시, 더 좋은 코드를 작성하기 위해 노력 필요
	* 보통은 && 연산자가 가독성에 좋음
* && 연산자
	* 삼항 연산자나 return을 여러개 두는 것은 반드시 null을 반환해야 함
	* && 연산자를 이용하면 null을 생략해도 됨
	* 사용시 주의할 점
		* 숫자 0, 빈 문자열은 false로 판단
		* 위 값을 참으로 하기 위해서는 null이나 undefined로 따로 처리 필요
* 변수가 배열인 경우 기본값을 빈 배열로 설정
	* && 연산자 없이 map 함수 이용 가능
* 상위 컴포넌트에서 하위 컴포넌트를 조건부 렌더링에 사용하는 경우
	* 하위 컴포넌트는 마운트/언마운트가 반복
		* 마운트/언마운트 반복 시, 컴포넌트의 상태값이 생성/삭제가 반복
		* 성능상 안좋은 영향이 끼칠 가능성 존재
	* 필요 조건이 상위 컴포넌트에 있어 자식 컴포넌트의 로직이 간단해지는 장점

### 관심사 분리 : 프레젠테이션 컴포넌트 및 컨테이너 컴포넌트
* 댄 아브라모프의 컴포넌트 구분법
	* 프레젠테이션 컴포넌트
		* UI와 관련된 부분만 담당
		* 상태값이 없음. 단, UI 효과를 위한 상태값은 제외
		* 속성값을 통해 모든 UI 데이터 및 콜백 함수를 전달 받음
		* 데이터를 직접 변경하지 않음
	* 컨테이너 컴포넌트
		* 데이터 핸들링 담당
		* 프레젠테이션 컴포넌트 및 다른 컨테이너 컴포넌트 관리
		* 상태 변경에 대한 로직 포함
		* 상태를 프레젠테이션 컴포넌트로 전달
* 관심사 분리
	* 복잡한 코드를 비슷한 기능을 하는 코드끼리 분리하는 작업
	* 코드가 복잡해진다면 관심사 분리가 필요한 순간일 가능성 있음
* 비즈니스 로직과 UI 자체에 대한 분리
	* 프레젠테이션 컴포넌트 및 컨테이너 컴포넌트는 관심사를 분리하는 작업


## Section 2. useEffect 훅 실전 활용법
### 의존성 배열을 관리하는 방법
* 부수 효과 함수에 사용하는 모든 함수 및 변수는 의존성 배열에 추가해야 한다
	* eslint의 exhausitive-deps 규칙을 리액트 팀에서 제공
	* 잘못 사용된 의존성 배열을 찾아 알려줌
* useEffect 훅에서 async await 함수 사용하기
	* 생각해야 할 점
		* 부수효과 함수는 반드시 함수를 반환해야 한다
		* async await 함수는 프로미스를 반환
	* 부수효과 함수를 async await 함수로 바로 사용하면 에러
		* 부수효과 함수 내에서 async await 함수를 따로 정의하여 사용해야 함
	* 부수효과 함수 외부에서 async await 함수 정의하기
		* 컴포넌트 내부에서 동일한 함수 재사용 가능
		* 의존성 배열에 정의한 async await 함수를 추가해야함
		* 렌더링할 때마다 해당 함수가 재정의되므로 useCallback 훅을 이용해야 함

### 의존성 배열을 없애는 방법
* 가능하다면 의존성 배열을 사용하지 않는 게 좋음
	* 의존성 배열은 관리하기 어려움
	* 함수가 의존성 배열에 들어가는 경우, useCallback 훅을 사용해야 함
* 부수 효과 함수 내에서 분기 처리하기
	* 의존성 배열을 입력하지 않고, 부수 효과 함수의 로직을 조건으로 처리
	* 이 경우, 의존성 배열은 아예 넣지 않음 
* 부수 효과 함수에서 상태값을 변경해야 하는 경우
	* 상태값 변경 함수에 함수를 입력하여 의존성 배열 제거
	* 이 경우, 의존성 배열은 아예 넣지 않음 
* useRef 활용하기
	* 속성값으로 전달되는 함수는 자주 변경되는 경우가 많음
	* 해당 함수가 렌더링 결과에 영향을 주지 않는다면 useRef 훅을 사용하여 의존성 배열 제거

## Section 3. 렌더링 속도를 올리기 위한 성능 최적화 방법
* 리액트 앱에서 가장 많은 CPU 리소스를 사용하는 것은 렌더링 작업
* 최초 렌더링 이후 데이터 변경 시 렌더링을 하는 작업
	* 이런 렌더링 결과를 재사용할지 판단
		* 속성값이나 상태값의 변경 사항을 비교
		* 재사용 가능하면 이후 단계 무시
	* 컴포넌트 함수 호출
	* 가상 돔끼리 비교하여 변경된 부분만 실제 돔에 반영
* 주의할 점
	* 평상시에는 성능 최적화를 고민하지 않고 편하게 개발
	* 성능 이슈가 생기는 경우에 최적화 고려

### React.memo로 렌더링 결과 재사용하기
* React.memo 함수로 감싼 컴포넌트
	* 속성값을 비교 함수를 호출
	* 비교 함수 값이 참인 경우 재사용 가능 -> 렌더링 중단
	* 비교 함수 값이 거짓인 경우 재사용 불가능 -> 렌더링 진행
	* React.memo로 감싸지 않으면 비교함수의 반환값이 항상 거짓이어서 부모 컴포넌트가 렌더링 될때마다 같이 렌더링 진행
* React.memo의 비교 함수
	* 두 번째 인자로 입력
	* 비교 함수를 입력하지 않으면, 얕은 비교를 수행
		* 즉 객체의 참조값이 같은지 여부만 확인
		* 객체의 속성값이 달라져도 참조값이 같으면 참으로 반환
	* 속성값을 불변 객체로 관리하는 이유
		* 불변 객체인 경우, 속성값이 달라지면 참조값이 달라짐
		* 추가적인 비교 함수를 정의할 필요없이 React.memo를 사용 가능

### 속성값과 상태값을 불변 변수로 관리하는 방법
* 함수의 값이 변하지 않도록 관리
	* 자식 컴포넌트의 속성값으로 함수를 입력하는 경우
		* 부모 컴포넌트가 렌더링 시, 해당 함수도 새롭게 정의
		* 자식 컴포넌트를 React.memo로 감싸도 속성값이 변경되었다고 판단
		* 무의미한 렌더링 발생
	* 함수 또한 불변값으로 관리해야함
		* useState 및 useReduer의 상태 변경 함수는 불변값이므로 이용 가능
		* 상위 컴포넌트에서 정의해야 하는 경우에는 useCallback 사용
* 객체의 값이 변하지 않도록 관리
	* 컴포넌트 내부에서 객체 정의 시, 컴포넌트 렌더링 시 새로운 객체 생성
		* 자식 컴포넌트로 해당 객체를 전달하는 경우, 불필요한 렌더링 발생
	* 렌더링과 무관한 객체의 경우, 외부 상수 변수로 관리
	* 내부에서 정의가 필요한 경우, useMemo 사용

### 가상 돔에서의 성능 최적화
* 가상 돔이 만들어지고 실제 돔에 반영되는 과정에서의 최적화
* 요소의 타입 또는 속성을 변경하는 경우
	* 조건부 렌더링으로 인해 요소의 타입이 변경 될 수 있음
	* 요소의 타입이 변경되면, 해당 요소의 자식 요소도 모두 변경
		* 자식 요소의 내용이 변경되지 않아도 실제 돔에서 삭제되고 다시 생성
		* 실제 돔의 삭제/생성 과정이 반복되면 성능이 매우 떨어짐
	* 요소의 타입이 변경되지 않도록 주의 필요
* 요소를 추가하거나 삭제하는 경우
	* 일반적으로 새로운 요소가 추가/삭제되는 경우, 해당 요소만 실제 돔에 추가/삭제
	* 중간에 있는 요소가 추가/삭제되는 경우
		* 추가/삭제 이후의 요소에 대해 변경 여부 파악 불가능
		* 이후의 요소들은 변경되지 않았음에도 불필요한 비교 연산 진행
		* key 속성값을 이용하여 해결
	* key 속성값
		* 리액트가 렌더링을 효율적으로 할 수 있도록 사용자가 제공하는 추가 정보
		* key 속성값을 지정하면, 리액트는 같은 키를 가지는 요소끼리만 비교
		* key 속성값이 변경되지 않은 요소들은 리액트에서 변경이 되지 않았다고 인식
		* 데이터의 id로 설정하는 것이 좋음
		* 배열의 끝에서만 원소가 추가/삭제하는 경우에는 배열의 인덱스로 설정 가능
			* 배열의 중간에 요소가 삽입되는 경우, 인덱스가 달라져서 비효율적인 렌더링 발생
			