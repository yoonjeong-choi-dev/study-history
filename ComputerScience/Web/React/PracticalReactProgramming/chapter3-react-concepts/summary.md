# Chapter 3. 중요하지만 헷갈리는 리액트 개념

## Section 1. 상태값과 속성값으로 관리하는 UI 데이터
### 리액트에서의 UI
* 리액트는 UI 라이브러리
  * UI 데이터를 관리하는 방법을 제공
  * 리액트의 UI 데이터
    * 컴포넌트 내부에서 관리되는 상태값
    * 부모 컴포넌트에서 전달하는 속성값
* Without UI 라이브러리
  * 비즈니스 로직과 UI 수정 코드가 뒤섞임
  * 코드 관리가 어려워짐
* 리액트는 컴포넌트 함수를 이용하여 화면을 자동으로 갱신
  * 컴포넌트 함수는 선언적으로 정의
  * **무엇을** 화면에 그리는지 정의
  * 돔 환경 뿐만 아니라 모바일 네이티브의 UI 또한 표현하는 방식

### 컴포넌트의 상태값과 속성값
* 리액트에서는 UI 데이터를 반드시 상태값과 속성값으로 관리
  * 상태값/속성값이 변경되는 경우에만 다시 렌더링
  * 다른 방식으로 UI 데이터를 관리하면, 리액트는 해당 데이터가 변경된 사실을 인지 불가능
* 상태값
  * useState 훅을 사용
  * useState 훅이 반환하는 상태 변경 함수를 호출하면, 해당 컴포넌트가 다시 렌더링
  * 상태값은 불변 변수로 관리하는 것이 좋음
    * 상태값을 직접 수정은 가능하지만, 리액트는 변경 사실을 인지 못함
* 속성값
  * 부모 컴포넌트가 전달한 데이터
  * 컴포넌트 함수의 props 인자를 통해 접근
  * 부모 컴포넌트가 렌더링될 때 같이 렌더링
    * 속성값의 변경 사항이 화면에 반영
  * 속성값이 변경될 때만 렌더링되길 원하면 React.memo 사용
    * 함수의 인자로 컴포넌트 입력
    * `export default React.memo(myComponent);`
  * 속성값은 불변 변수
    * 상위 컴포넌트에서 관리하는 변수이기 때문에 변경이 막혀 있음
    * 하위 컴포넌트에서 변경하려 하면 에러 발생


## Section 2. 리액트 요소와 가상 돔
* 리액트 요소(element)는 리액트가 UI를 표현하는 수단
  * JSX 문법을 사용하기 때문에 리액트 요소의 존재를 잘 모름
  * React.createElement 가 반환하는 것이 리액트 요소
* 렌더링 성능을 위해 가상 돔 활용
  * 브라우저가 돔을 변경하는 작업은 매우 비싼 작업
  * 브라우저의 렌더링 성능을 위해 돔 변경을 최소화 해야함
  * 메모리에 가상 돔을 올려 놓고, 변경 전후의 가상 돔 차이를 비교하여 실제 돔에 반영

### 리액트 요소
* React.createElement 가 반환하는 것이 리액트 요소
* 리액트 요소의 구조
  * type
    * 문자열인 경우 HTML 태그
    * 문자열이 아닌 경우, 리액트 컴포넌트
  * key
    * 배열로 구성된 엘리먼트를 지정
    * 어떤 배열 요소를 변경/추가/삭제할지 식별하는데 도움이 되는 값
  * ref
    * ref 속성값에 해당
    * [Section 5 참고](#Section-5.-ref-속성값으로-자식-요소-접근하기)
  * props
    * key, ref를 제외한 나머지 속성값은 props의 속성값으로 저장
* 전달된 리액트 요소를 이전 리액트 요소와 변경하여 변경된 부분만 실제 돔에 반영
  * 컴포넌트의 속성값이 변경되면, 리액트 요소의 props 내부 값이 변경
    => 해당 컴포넌트를 다시 렌더링
* 하나의 화면을 표현하기 위해 다수의 리액트 요소들이 트리 구조로 구성

### 리액트 요소가 돔으로 만들어지는 과정
* 데이터 변경에 의한 화면 업데이트의 2가지 단계
  * 렌더 단계
    * 실제 돔에 반영할 변경 사항을 파악하는 단계
    * 변경 사항을 파악하기 위해 가상 돔을 활용
  * 커밋 단계
    * 렌더 단계에서 파악된 변경 사항을 실제 돔에 반영하는 단계
* 가상 돔
  * 리액트 요소를 이용하여 구성
    * 렌더링을 할 때마다 가상 돔을 만들어 이전의 가상 돔과 비교
    * 실제 돔의 변경 사항을 최소화하기 위한 과정
  * 실제 돔을 만들 수 있는 리액트 요소 트리
    * type이 문자열이 될 때까지 리액트 요소 트리를 탐색
      * type이 문자열이어야 실제 HTML 태그로 변환 가능
      * 리액트 컴포넌트도 결국 HTML 태그로 구성되어 있으므로, 트리르 탐색하면서 컴포넌트 함수가 호출
    * 렌더 단계는 가상 돔의 변경 사항을 파악하여 실제 돔에 반영할 내용을 결정하는 것



## Section 3. 리액트 훅 기초 익히기
* 훅은 함수형 컴포넌트에 기능을 추가할 때 사용되는 함수

### useState : 상태값 추가하기
* 컴포넌트에 상태값을 추가할 때 사용
* 배치로 처리되는 상태값 변경 함수
  * 리액트는 16ms 단위로 batch update 진행
    * 해당 기간동안 변경된 상태값들을 모아서 한번에 렌더링
  * 상태값 변경 함수는 비동기로 동작
    * (상태값 변경 -> 화면 렌더링) 작업이 비동기 처리 i.e 배치 시간동안 집계하여 한번에 처리
    * 동기로 처리하면, 함수를 호출 할때 마다 화면을 다시 그리는 작업이 동기적으로 처리되어 성능상 이슈
    * 동기로 처리하면서, 매번 화면을 다시 그리는지 않으면 UI 데이터와 화면 사이 불일치 발생
  * 리액트는 가능하면 상태값 변경을 배치로 처리
    * 상태값 함수를 연속으로 호출하여도, 현재 상태값은 동일
      ```
      const [num, setNum] = useState(0);
      setNum(num+1);  // 현재 num의 값은 1, 변경되는 상태값은 2
      setNum(num+1);  // 비동기 작업이기 때문에 현재 num의 값은 1
      ```
    * 즉 상태값 함수를 연속으로 호출하여도 한번만 반영되는 것처럼 보임
* 상태값 변경 함수에 함수 입력
  * 인수로 들어가는 함수는 자신이 호출되기 직전의 상태값을 매개변수로 받음
    * `setCount(prev => prev+1)`
    * 인수로 들어가는 함수는 리액트 배치 업데이트 시 호출
  * 상태값 변경 함수를 여러 번 호출하면서도 모두 반영되도록 가능
* 객체 타입의 상태값 관리
  * 클래스형 컴포넌트의 setState 메서드와의 차이점
    * setState은 기존 상태값과 새로 입력되는 상태값을 병합
    * useState은 이전 상태값을 덮어 씌움
  * 이전 상태값을 덮어 씌우기 때문에, 객체의 전개 연산자가 필요
    * `setObject({...object, id: 'change'})`
    * 상태값을 하나의 객체로 관리하는 경우 [useRef](#useRef) 훅을 사용하는 곳이 좋음

### useEffect : 부수 효과 처리하기
* 부수 효과
  * 함수 실행 시, 함수 외부의 상태를 변경하는 연산
  * 특별한 이유가 없다면, 컴포넌트의 모든 부수 효과는 useEffect 훅을 사용하는 것을 권장
  * 예시
    * API 호출
    * 이벤트 처리 함수 등록
* useEffect 구성 요소
  * `useEffect(부수 효과 함수, 의존성배열)`
  * 부수 효과 함수
    * 컴포넌트 렌더링 시, 실행하는 매개변수가 없는 함수
    * 렌더링 결과가 실제 돔에 반영된 후에 비동기로 호출
    * 부수 효과 함수가 반환하는 함수는 부수 효과 함수가 호출되기 직전 및 컴포넌트가 사라지기 직전에 호출
  * 의존성 배열
    * 배열의 값이 변경되는 경우에만 함수가 호출
    * 의존성 배열이 없는 경우, 컴포넌트가 렌더링 될 때마다 호출
    * 빈 배열인 경우, 컴포넌트가 생성될 때 한번만 부수 효과 함수가 실행

### 훅 사용시 주의점
* 훅 사용을 위한 기본 원칙
  * 하나의 컴포넌트에서 혹을 호출하는 순서는 **항상** 같아야 한다
  * 함수형 컴포넌트 또는 커스텀 훅 안에서만 호출되어야 한다
* 호출 순서가 보장되지 않는 예시
  * 조건에 따라 호출 여부가 결정되는 경우
  * 반복문 루프 내에서 호출하는 경우
  * 컴포넌트 내부에 정의된 함수 블럭 내에서 호출하는 경우
    * 해당 함수가 언제 호출되는지 보장을 못함
* 리액트에서 훅을 다루는 방식
  * 각 컴포너트는 hooks라는 배열을 가지고 있음
  * 컴포넌트 생성 시, hooks는 빈배열로 초기화
  * 컴포넌트 내부에서 훅 사용 시, hooks 배열에 해당 훅에 대한 데이터 추가
  * 리액트는 hooks에 저장된 순서로르 기반으로 훅을 관리


## Section 4. Context API
* 상위 컴포넌트에서 하위 컴포넌트로 데이터를 제공하는 방법
  * 보통은 속성값을 사용
  * 많은 수의 하위 컴포넌트로 속성값을 전달하는 경우, 중간에 있는 컴포넌트는 기계적으로 속성값을 전달하는 문제 발생
  * Context API를 사용하면, 상위 컴포넌트에서 모든 하위 컴포넌트로 직접 데이터 전달 가능

### Context API 이해하기
* React.createContext 함수를 호출하여 컨텍스트 객체 생성
  * 반환 값은 (Provider, Consumer)
  * 상위 컴포넌트는 Provider를 통해 데이터 전달
  * 하위 컴포넌트는 Consumer를 통해 데이터 접근
* Provider 컴포넌트의 속성값이 변경되면, 하위 모든 Consumer 컴포넌트는 다시 렌더링
  * 중간에 위치한 컴포넌트의 렌더링 여부와 관련없이 다시 렌더링
  * 중간 컴포넌트들은 React.memo로 감싸서 다시 렌더링되지 않도록 최적화 가능

### Context API 활용하기
* 여러 컨텍스트 중첩해서 사용
  * Provider 및 Consumer 컴포넌트를 중첩하여 사용 가능
  * 데이터 종류 별로 컨텍스트를 만들어 사용하는 것 권장
    * 특정 데이터 변경 시, 해당 컨텍스트 Consumer가 있는 컴포넌트만 다시 렌더링
    * 렌더링 성능에 이점을 줌
* 하위 컴포넌트에서 컨텍스트 데이터 수정
  * 리덕스의 디스패치 함수와 같은 기능
  * 데이터 수정하는 함수를 상위 컴포넌트에서 정의하여 컨텍스트를 통해 하위 컴포넌트로 전달하는 방식
  * example
    ```
    const UserContext = React.createContext({username: ''});
    const SetUserContext = React.createContext(()=>{}); // 깡통 함수로 초기화
    const App = () => {
      const [user, setUser] = useState('');
      return (
        <div>
          <SetUserContext.Provider value={setUser}>
            <UserContext.Provider value={user}>
              <Profile/>
            </UserContext.Provider>
          </SetUserContext.Provider>
        </div>
      )
    }
    ```

### Context API 사용시 주의점
* 불필요한 렌더링 발생
  * 컨텍스트 데이터로 객체 사용시 주의 필요
  * Provider를 사용하는 컴포넌트가 다시 렌더링될 때마다 새로운 객체로 생성되어 전달
    * 새로운 객체가 생기는 것은 컨텍스트 데이터가 변경된 것으로 인지
    * 상위 컴포넌트가 해당 값 변경없이 다시 렌더링되면, 하위 컴포넌트는 무의미한 렌더링 발생
* Consumer 컴포넌트는 반드시 Provider 컴포넌트의 하위 컴포넌트로 존재해야 한다

## Section 5. ref 속성값으로 자식 요소 접근하기
### ref 속성값 이해하기
* 돔 요소에 직접 접근해야하는 상황
  * 돔 요소에 포커스 주기
  * 돔 요소의 크기나 스크롤 위치 확인
* ref 속성값을 이용하여 자식 요소에 직접 접근 가능
  * 자식 요소는 컴포넌트일수도, 돔 요소일수도 있음
* useRef 훅
  * ref 객체를 반환
  * ref 객체를 자식 컴포넌트의 ref 프로퍼티에 설정함
  * ref 객체의 current를 이용하여 자식 요소 접근 가능
    
### ref 속성값 활용하기
* ref 속성값으로 함수 사용하기
  * ref 속성값으로 함수를 설정하면, 해당 자식 요소가 생성되거나 제거되는 시점에서 호출
  * 속성값으로 새로운 함수가 들어오면, 이전 함수에 null 인수를 넣어 호출

### ref 속성값 사용시 주의점
* 컴포넌트가 생성된 후라도 ref 객체의 current 속성이 없을 수 있음
  * 조건부 렌더링의 경우 발생하는 문제
  * 조건부 렌더링에 사용되는 요소의 ref 객체는 current 속성에 대한 널 체크 필요


## Section 6. 리액트 내장 훅
### useContext
* Consumer 컴포넌트 없이 상위 컴포넌트에서 전달한 컨텍스트 데이터 사용 가능
  * 컨텍스트 데이터를 사용하는 컴포넌트 함수 전체 영역에서 접근 가능
  * useContext({컨텍스트 객체})를 통해 해당 컨텍스트로 전달된 데이터 접근

### useRef
* 두가지 용도
  * ref 객체를 사용하여 자식 요소 접근
  * 컴포넌트 내부의 값들 중 렌더링과 무관한 데이터들 저장

### useMemo, useCallback
* 이전 값을 기억하여 성능을 최적화하는 용도로 사용되는 훅
* useMemo
  * 값 = useMemo(함수, 의존성 배열)
  * 인자로 받은 함수의 반환값을 기억
  * 의존성 배열이 변경되지 않으면, 기억하고 있는 반환값을 계속 사용
  * useMemo로 넘긴 함수의 비용이 비싼 경우 최적화에 유용
* useCallback
  * 함수 자체를 기억하는 훅
    * 메모된함수 = useCallback(함수, 의존성 배열)
    * 의존성 배열이 변경되지 않으면 메모된 함수를 계속 사용
  * 불필요한 속성값이 변경되어 컴포넌트가 렌더링되는 상황 예시
    * 하위 컴포넌트의 속성값으로 상위 컴포넌트에서 정의한 함수를 넘김
    * 상위 컴포넌트가 다시 렌더링되면, 정의된 함수는 새로운 함수 객체로 생성됨
    * React.memo를 사용하더라도, 상위 컴포넌트의 변경은 하위 컴포넌트를 반드시 렌더링하게 만든다
  * 하위 컴포넌트로 함수를 넘길 때, 사용하면 최적화에 도움이 됨

### useReducer
* 리덕스의 리듀서처럼 컴포넌트의 상태값을 관리할 때 사용
  * 리듀서의 자세한 설명은 Chapter6. 리덕스 참조
* `const [state, dispatch] = useReducer(reducer, INIT_STATE)`
  * ruducer
    * 현재 상태와 액션을 인자로 받아 다음 상태를 반환하는 함수
    * 액션 타입(action.type)에 따라 상태의 다음 상태를 반환
  * state : ruducer에서 관리하는 상태
  * dispatch : 변경사항을 인자로 넣어 상태를 변경시키는 함수
* 트리 깊은 곳으로 이벤트 처리 함수 전달
  * 보통 상위 컴포넌트에서 다수의 상태값을 관리
    * 하위 컴포넌트는 상위 컴포넌트에서 관리하는 상태값을 이용하여 렌더링
    * 하위 컴포넌트에서 발생한 이벤트에서 상위 컴포넌트의 상태값을 변경해야 하는 상황이 자주 발생
  * useReducer와 컨텍스트 API를 사용하여 상위 컴포넌트에서 하위 컴포넌트로 이벤트 처리 함수를 전달 가능
    * dispatch 함수를 전달하는 컨텍스트 객체 생성
    * Provider 컴포넌트를 통해 하위 컴포넌트로 해당 함수 전달
* useReducer의 dispath 함수는 값이 변하지 않아 Consumer 컴포넌트가 불필요하게 렌더링되는 현상 발생 X


### 기타 내장 훅 : useLayoutEffect, useDebugValue
* useLayoutEffect 
  * useEffect 처럼 부수효과를 처리하는 훅
  * useEffect와 다르게 **동기적**으로 부수 효과 함수를 호출
    * 렌더링 결과가 돔에 반영된 직후 호출
    * 연산이 많은 부수 효과 함수를 지정한 경우, 브라우저가 먹통이 될 가능성 높음
  * 보통은 useEffect 사용
  * 렌더링 직후의 돔 요소의 값을 읽어야 하는 상황 같은 경우에만 useLayoutEffect 사용
* useDebugValue
  * 커스텀 훅의 내부 상태를 관찰 하는 훅
  * 리액트 개발자 도구를 통해 확인 가능
