# Chapter 7. 객체 지향 프로그래밍 (2)

## 상속
* extends 키워드를 통해 상속
  * **생성자 및 초기화 블럭은 상속되지 않는다**
  * 멤버만 상속
    * 멤버 변수
    * 메서드
  * 접근 제어자는 상속 대상을 제어하는 것이 아닌, 자식 클래스에서 접근 가능 여부를 제어하는 것
* 포함 관계(composite)
  * 상속과 비슷하게 클래스를 재사용하는 방법
  * 클래스의 멤버 변수로 다른 클래스 타입의 참조 변수를 선언하는 것
  * 상속의 단점을 보완
    * 다중 상속 불가능
    * 상속 구조가 복잡해지면, 상위 클래스의 변경에 대한 예측이 어려움
* 상속 vs 포함
  * 상속 : is-a
  * 포함 : has-a
* Object 클래스
  * 모든 클래스 상속 계층의 최상위에 위치하는 클래스
  * 다른 클래스로부터 상속을 받지 않은 클래스는 자동적으로 상속
  * 다른 클래스로부터 상속을 받은 클래스는, 조상 클래스를 추적하면 가장 마지막에 만나는 클래스
  * Object 클래스의 멤버를 사용 가능
    * toString()
    * equals()
    * etc..

## 오버라이딩
* 상속받은 메서드의 내용을 변경하는 것
* 오버라이딩 조건 : 선언부가 일치
  * 메서드의 이름
  * 메서드의 매개 변수
  * 메서드의 반환 타입
  * 클래스 메서드와 인스턴스 메서드 간 변경 불가능
* 추가 조건
  * 접근 제어자
    * 조상 클래스의 접근 제어자보다 좁은 범위로 변경 불가능
  * 예외(Exception)
    * 조상 클래스에서 선언된 예외의 개수보다 많은 예외 선언 불가능
    * 즉, 조상 클래세에서 선언된 예외보다 추상적인 예외는 선언 불가능

## super
* 자손 클래스에서 자신이 상속 받은 조상 클래스에 대한 참조 변수
  * super.var 형식으로 조상 클래스의 변수 참조
  * super.method() 형식으로 조상 클래스의 메서드 호출
* super(...) 생성자
  * 조상 클래스의 생성자를 호출하는데 사용
    * 자손 클래스의 생성자에서 반드시 호출해야 함
    * 호출하지 않으면, 컴파일러는 자동으로 생성자 첫줄에 `super();` 추가
  * 클래스의 상송 관계를 거슬러 올라가 Object 클래스의 생성자인 `Object()`까지 호출
  * 자동으로 추가되는 `super()`의 문제점
    * 조상 클래스가 기본 생성자(매개변수가 void)를 정의 하지 않은 경우
    * i.e 매개 변수를 받는 생성자를 정의한 경우
    * 조상 클래스의 기본 생성자가 없어 `super()`에서 컴파일 에러

## 패키지와 import
* 패키지(package)
  * 클래스/인터페이스 묶음
  * 서로 관련된 클래스/인터페이스를 그룹 단위로 묶음으로써 효율적으로 관리 가능
  * 패키지는 물리적으로 하나의 디렉터리
    * 클래스 파일(.class)로 구성
    * 디렉터리가 하위 디렉터리를 가지는 것처럼 패키지도 다른 패키지 포함
    * `package1.package2.class1` 과 같은 형식
* 패키지 규칙
  * 하나의 소스파일은 첫번째 문장으로 단 한번 자신이 속한 패키지 선언 허용
    * `package package1.package2;` 형식
  * 패키지 이름은 클래스명과 구분하기 위해 소문자 권장
    * 클래스명은 카멜 케이스 
    * i.e 클래스명은 첫글자가 대문자
  * 모든 클래스는 반드시 하나의 패키지에 속해야 한다
    * 즉, 소스파일 첫번째 문장에 특정 패키지 선언 필요
    * 이름없는 패키지(unnamed package)
      * 자신이 속하는 패키지를 지정하지 않은 경우, 자동적으로 속하는 패키지
      * 패키지 선언이 없어도 문제가 없는 이유
* java 명령어의 -d 옵션
  * `java -d classes code.java`
  * classes 디렉터리를 루트 경로로 code.java에 대한 클래스 파일 생성
  * code.java에서 지정된 패키지 디렉터리가 없는 경우 패키지의 계층 구조에 맞게 디렉터리 자동으로 생성
* 클래스패스(classpath)
  * 컴파일러(javac) 및 JVM(java) 등이 클래스들의 위치를 찾는데 사용하는 루트 경로
    * 외부 클래스를 사용하는 코드를 컴파일/실행할 때 외부 클래스를 참조하기 위해 해당 클래스 파일을 찾는 기준 경로
  * 코드가 속하지 않은 클래스를 사용하는 경우 설정 필수
    * 클래스패스를 설정하지 않은 경우, 기본값으로 현재 경로를 클래스패스로 지정
    * `CLASSPATH=$CLASSPATH:somedir`형식으로 환경변수로 설정 가능
  * JDK에서 기본으로 설정된 클래스패스에 추가하는 방법
    * `$JAVA_HOME/jre/bin`: 클래스파일(.class)
    * `$JAVA_HOME/jre/lib/ext`: jar 파일\
  * -cp 옵션을 통한 클래스패스 지정
* import 구문
  * 기본적으로 자신이 속하지 않은 패키지의 클래스를 사용하지 위해서는 패키지명이 포함된 클래스 이름으로 사용해야 함
    * **클래스의 전체 이름** : 해당 클래스가 속한 모든 패키지 정보가 들어있는 방식
    * ex) `java.util.Date`
    * 네임스페이스 역할
  * import 구문을 통해 클래스의 전체 이름에서 특정 패키지에 대한 이름 생략 가능
    * without import
    ```
    java.util.Date myDate = new java.util.Date();
    ```
    * with import
      * ```
        import java.util.*;
        util.Date myDate = new util.Date();
        ```
      * ```
        import java.util.Date;
        Date myDate = new Date();
        ```
  * java.lang
    * System 및 String 클래스들이 속한 패키지
    * `import java.lang.*;` 선언없이 사용 가능
    * (why?) java.lang 패키지의 경우 프로그래밍 시 빈번하게 사용되어 명시적으로 import하지 않아도 컴파일러가 알아서 처리하도록 설계
  * static import
    * static 멤버(변수/메서드)를 호출할 때 클래스명 생략 가능
    * ```
      import static java.lang.Math.random;
      import static java.lang.System.out;

      out.println(random());
      ```

## 제어자(modifier)
* 제어자란?
  * 클래스/변수/메서드의 선언부에 사용되어 부가적인 의미를 부여하는 키워드
  * 종류 1: 접근 제어자
    * public
    * protected
    * default
    * private
  * 종류 2: 그외 제어자
    * static
    * final
    * abstract
    * native
    * transient
    * synchornized
    * volatile
    * stricttp
* static
  * '클래스의', '공통적인'을 의미
  * 인스턴스가 아닌 클래스와 관련된 정보
    * 인스턴스 생성 없이 사용 가능
    * 모든 인스턴스가 공유
  * 클래스가 메모리 로드 시, 단 한번만 수행
* final
  * '마지막의', '변경될 수 없는'을 의미
  * 적용 범위
    * 변수 : 값을 변경할 수 없는 상수
    * 메서드 : 오버라이딩 불가능
    * 클래스 : 상속 불가능
  * 초기화 시기
    * 일반적인 스택 변수의 경우 선언과 동시에 초기화 필요
    * 인스턴스 변수의 경우 생성자를 통해 초기화 가능
* abstract
  * 추상 클래스
    * 클래스 키워드 앞에 붙임
    * 해당 클래스에 추상 메서드가 있음을 의미
    * 추상 클래스 자체로는 인스턴스 생성 불가능
  * 추상 메서드
    * 선언만 있을 뿐, 구현부가 없는 메서드
    * 상속 및 오버라이드를 통해 구현이 필요한 메서드
  * 추상 메서드가 없는 추상 클래스
    * 모든 메서드가 구현되어 있으나, 인스턴스로 생성이 불가능한 클래스
    * 인터페이스와 비슷한 역할 가능
    * 모든 메서드를 구현해야 하는 인터페이스와 다르게 특정 필요 기능들만 오버라이드로 구현할 수 있는 장점
    * ex) `java.awt.event.WindowAdapter`
* 접근 제어자
  * 멤버 또는 클래스에 사용되어, 해당 멤버/클래스의 접근 범위를 제한하는 키워드
  * 종류
    * private
      * 같은 클래스 내에서만 접근 가능
      * 가장 높은 제한
    * default
      * 같은 패키지 내에서만 접근 가능
      * 접근 제어자를 선언하지 않은 경우 기본적으로 설정되는 접근 제어자
    * protected
      * 패키지 상관없이 상속 관계에 있는 자손 클래스에서 접근 가능
      * 같은 패키지 내에서는 상속 관계 없이 접근 가능 i.e default와 동일
      * default 보다 접근 범위가 넓음
    * public
      * 모든 곳에서 접근 가능
      * 접근 제한이 전혀 없는 지시어
      * 하나의 소스 파일에는 public 클래스가 단 하나여야 하며, 해당 public 클래스의 이름과 소스파일의 이름은 일치해야 한다
  * 접근 제어자를 사용하는 이유 : 캡슐화
    * 외부로부터 데이터를 보호
    * 외부에는 불필요한 내부적으로 사용하는 부분을 감추기 위해서
    * 접근 범위가 커질 수록, 코드 변경 시 테스트해야하는 범위가 넓어진다
  * 멤버 변수의 접근 제어(setter/getter)
    * 멤버 변수는 자체는 private/protected를 통해 직접 접근을 제한해야 안전
    * setter
      * set멤버변수(값) 형식
      * 해당 멤버 변수를 변경하는 메서드
    * getter
      * get멤버변수() 형식
      * 해당 멤버 변수의 값을 반환하는 메서드
  * private 생성자
    * 싱글턴 패턴
      * 생성자에 private을 사용함으로써 외부에서 인스턴스 생성을 막음
      * 인스턴스를 생성 및 반환해주는 public static 메서드를 통해 인스턴스 제공
      * 해당 클래스의 인스턴스 개수를 제한하기 위해 사용
    * 상속 불가능
      * 자손 클래스에서 부모 클래스의 생성자를 호출해야 하는데, 생성자가 private
      * 이 경우 클래스 앞에 fianl 키워드를 붙여 상속할 수 없는 클래스임을 알리는 것이 좋음
* 제어자 조합이 불가능한 형태
  * 메서드의 static + abstract
    * static 메서드는 구현부가 있는 메서드에서만 사용 가능
  * 클래스의 abstract + final
    * abstract : 상속을 통해서만 완성
    * final : 상속 불가능
  * 메서드의 abstract + private
    * abstract : 자식 클래스에서 구현 필요
    * private : 자식 클래스에서 접근 불가능

## 다형성(polymorphism)
* OOP에서의 다형성
  * 한 타입의 참조변수로 여러 타입의 객체를 참조할 수 있는 기능
  * 조상클래스 타입의 참조변수로 자손 클래스의 인스턴스를 참조할 수 있는 기능
  * 같은 인스턴스라도 참조변수의 타입에 따라 접근 가능한 멤버가 달라짐
* 참조변수의 형변환
  * 서로 상속 관계에 있는 클래스사이에서만 형변환 가능
  * 업 캐스팅(up-casting)
    * 자손 타입의 참조 변수를 조상 타입의 참조 변수로 변환
    * 형변환 연산자 생략 가능
      * (why?) 조상 타입 참조 변수가 다룰 수 있는 멤버의 개수가 실제 인스턴스가 가지고 있는 멤버 개수보다 적은 것이 분명하기 때문
  * 다운 캐스팅(down-casting)
    * 조상 타입의 참조 변수에서 자손 타입의 참조 변수로 변환
    * 명시적 형변환 필요
  * 형변환은 인스턴스 자체에 영향 X
    * 참조변수의 타입을 변환하는 것일 뿐, 인스턴스를 변환하는 것이 아님
    * 참조 변수는 참조하고 있는 인스턴스에서 사용할 수 있는 멤버의 범위를 조절하는 것
  * ClassCastException
    * 명시적 형변환에서 형변환이 불가능한 인스턴스의 참조 변수를 형변환할 때 발생하는 런타임 에러
    * 컴파일러는 참조 변수 자체에 대한 형변환만 체크하기 때문에, 인스턴스가 해당 참조 변수로 참조가 가능한지 여부는 런타임에서만 알 수 있음
* instance 연산자
  * ```a instanceof A```
    * 인스턴스 a가 참조 변수 타입 A로 참조 가능한지 여부
    * 인스턴스 a가 클래스 A 및 하위 클래스로 생성된 인스턴스인지 여부
    * 인스턴스 a의 참조 변수를 참조 변수 A 타입으로 형변환 가능한지 여부
* 참조 변수와 인스턴스 변수의 관계
  * **참조 변수의 타입에 영향을 받지 않는 것은 인스턴스 메서드 하나**
    * 인스턴스 메서드를 오버라이딩한 경우, 참조 변수 타입에 상관없이 실제 인스턴스의 메서드가 호출
  * 인스턴스 변수의 경우, 참조 변수 타입에 따라 달라질 수 있음
    * 조상 클래스와 자식 클래스에서 동일한 변수에 대해서 멤버 변수로 선언한 경우
    * 조상 클래스 참조 변수 타입에서는 조상 클래스에서 정의된 멤버 변수로 접근
    * 즉, 같은 이름의 멤버 변수를 자식 클래스에서 중복되게 정의하고, 외부에서 접근할 때 발생하는 문제
  * 인스턴스 변수에 직접 접근하는 경우, 참조 변수 타입에 따라 사용되는 인스턴스 변수가 달라짐을 의미

# 인터페이스(interface)
* 일종의 추상 클래스
  * 추상 클래스보다 추상화 정도가 더 높음
  * 오직 추상 메서드 및 상수만으로 구성
  * 어떤한 기능 또는 행위의 집합을 정의하는 역할
  * 인터페이스 자체로 사용되지 않고, 다른 클래스로 구현을 해줘야 함
* 인터페이스 멤버들의 제약 사항
  * 멤버 변수는 public static final 형태
  * 메서드는 public abstract 형태
    * 예외 static, default (1.8~)
  * 위 키워드들은 생략이 가능하며, 컴파일러가 자동으로 붙여준다
* default 메서드
  * 인터페이스의 메서드 추가 시, 모든 구현 클래스에 추가된 메서드를 구현해야 하는 문제점 발생
  * default 메서드는 추상 메서드의 기본적인 구현을 제공하는 메서드
    * 디폴트 메서드가 추가되어도, 구현 클래스에서 추가적인 작업이 불필요
    * 일반 메서드처럼 구현부(몸통)이 있음
    * 접근제어자는 인터페이스 메서드들과 동일한 public
  * 이름 충돌 문제
    * 여러 인터페이스 간 디폴트 메서드 충돌 시, 구현 클래스에서 오버라이딩 필요
    * 조상 클래스와 디폴트 메서드 충돌 시, 조상 클래스의 메서드가 상속
* 인터페이스의 상속
  * 인터페이스로부터만 상속이 가능
  * 클래스와 달리 다중 상속 가능
    * 메서드 자체에 구현부가 없음
    * 중복된 메서드 이름을 가진 인터페이스들을 구현한다하여도, 해당 메서드 하나만 구현하면 됨
* 인터페이스의 장점
  * 개발 시간 단축
    * 메서드를 호출하는 쪽에서는 인터페이스를 통해 메서드 선언부만 알면 개발 가능
    * 메서드를 구현하는 쪽에서는 인터페이스를 구현한 클래스 개발
    * 독립적인 개발 가능
  * 표준화 가능
    * 프로그램에 사용되는 기본틀을 인터페이스로 정의
    * 인터페이스를 통해 일관되고 정형화된 프로그램 개발 가능
  * 서로 관계없는 클래스간 연결
    * 서로 상속 관계가 없는 클래스들에게 하나의 인터페이스를 구현함으로써 관계를 맺어줄 수 있음
  * 독립적인 프로그래밍
    * 클래스의 선언과 구현의 분리 가능
    * 클래스 간의 직접적인 관계를 인터페이스를 이용하여 간접적 관계로 추상화 가능
    * 클래스의 변경이 다른 클래스에 영향을 주지 않는 독립성
* 인터페이스 예시 : 데이터베이스
  * 데이터베이스 관련 인터페이스를 정의하여 데이터베이스 특정 제품에 의존하지 않는 개발 가능
  * 데이터베이스를 이용하는 프로그램에서는 인터페이스를 이용하여 개발
  * 데이터베이스 회사에서는 인터페이스를 구현한 클래스를 제공
  