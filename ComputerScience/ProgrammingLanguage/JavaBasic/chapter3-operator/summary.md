# Chapter 3. 연산자

## 형변환
* 자동 형변환
	* 컴파일러가 자동적으로 형변환
	* 작은 타입 -> 큰 타입의 경우에만 자동 형변환 가능
	* 큰 타입 -> 작은 타입의 경우 컴파일 에러
* 명시적 형변환
	* 큰 타입 -> 작은 타입의 경우 컴파일 에러 발생 x
	* 이 경우 사용자가 형변환에 의해 데이터의 손실 및 변경이 있는 것을 인지한다고 생각

## 산술 변환
* 연산 전에 피연산자 타입의 일치를 위한 자동 형변환
* 피연산자의 타입이 **int보다 작은 경우** int 타입으로 변환
	* byte, short -> int
	* char, short -> int
	* int 보다 작은 타입들에 대해 연산 후 저장하기 위해서는 결과에 대한 명시적 형변환 필요
		```
		byte a = 10, b = 20;
		byte c = (byte) (a + b);
		```
* 두 피연산자의 타입을 일치하도록 큰 타입으로 형변환
	* long, int -> long
	* float, int -> float
	* double, float -> float 
* 연산 결과에 대한 형 변환
	* 연산 결과를 변수에 저장할 때 주의해야 할 사항
	* 연산 결과 자체에 대한 명시적 형변환을 하지 않으면, 저장할 변수 타입이 커도 오버플로우 등의 오류 발생
* 리더털 간의 연산
	* 상수 또는 리터럴 간의 연산은 컴파일러가 계산하여 형변환 없이 결과 출력
		* 상수나 리터럴은 런타임에 변하지 않음 i.e 변수가 아님
		* 컴파일러가 해당 값을 알고 있기 때문에 가능한 현상
	* example
	```
	char c1 = 'a';
	char c2 = c1 + 1;	// 컴파일 에러
	char c3 = 'a' + 1;	// 컴파일 에러 x, c3=='b'
	```

## 비트 연산자
* 연산자 종류
	* &, |, ^
	* \>>, <<
* 피연산자의 타입이 int 보다 작으면 int로 형변환
* \>>, <<의 두번째 피연산자 n
	* `a << n`
	* 변수 a의 비트 수보다 n이 큰 경우, (n % (bit of a))만큼 이동
* 곱셈 및 나눗셈에 비해 속도가 빠름
	* 속도의 최적화를 위해서 사용 가능
	* (but) 가독성이 떨어짐

## 대입 연산자
* lvalue & rvalue
	* lvalue
		* 대입 연산자의 왼쪽 피연산자
		* 변수처럼 값을 변경할 수 있는 것들만 가능
	* rvalue
		* 대입 연산자의 오른쪽 피연산자
		* 변수, 상수, 식 등 모두 가능